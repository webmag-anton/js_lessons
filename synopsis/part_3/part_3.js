

					/*** Тематические разделы ***/



		/*--- Фреймы и окна ---*/								


		// Открытие окон и методы window
			
// Pop-up - отдельное окно со своим JavaScript-окружением (в отличае от модальных 
// окон: alert, форма callback...). Всплывающее окно блокируется в том случае, если 
// вызов window.open произошёл не в результате действия посетителя (например, события click)

// Открытие нового окна: 
window.open(url, name, params):
- URL для загрузки в новом окне
- name - имя нового окна; у каждого окна есть свойство window.name, в котором можно задавать, 
какое окно использовать для попапа; таким образом, если уже существует окно с заданным 
именем – указанный в параметрах URL откроется в нем, в противном случае откроется новое окно
- params - строка параметров для нового окна; содержит настройки, разделённые запятыми без пробелов
// например: 
// let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
// width=0,height=0,left=-1000,top=-1000`;
// open('/', 'test', params);

// Доступ к попапу из основного окна:
// Вызов open возвращает ссылку на новое окно. Эта ссылка может быть использована для управления 
// свойствами окна, например, изменения положения и др., например:
// let newWin = window.open("about:blank", "hello", "width=200,height=200");
// newWin.document.write("Hello, world!");

// Доступ к открывшему окну из попапа:
// Попап также может обратиться к открывшему его окну по ссылке window.opener.

win.close() - чтобы закрыть окно     
win.closed  - для проверки, закрыто ли окно

// Методы focus()/blur() и события focus/blur применимы для Pop-up окон



		// Общение между окнами

// Политика «Одинакового источника» (Same Origin) ограничивает доступ окон и фреймов друг к другу.
// Идея заключается в том, что если у пользователя открыто две страницы: john-smith.com и gmail.com, 
// то у скрипта со страницы john-smith.com не будет возможности прочитать письма из gmail.com.

// если у нас есть ссылка на другой объект window, например, на всплывающее окно, созданное с помощью 
// window.open или на window из <iframe> и у этого окна тот же источник, то к нему будет полный доступ

// Внутри <iframe> находится по сути отдельное окно с собственными объектами document и window
iframe.contentWindow   - ссылка на объект window внутри <iframe>
iframe.contentDocument - ссылка на объект document внутри <iframe>

// Событие iframe.onload – по сути то же, что и iframe.contentWindow.onload. Оно сработает, когда 
// встроенное окно полностью загрузится со всеми ресурсами. Но iframe.onload всегда доступно извне ифрейма, 
// в то время как доступ к iframe.contentWindow.onload разрешён только из окна с тем же источником.

// Другой способ получить объект window из <iframe> – забрать его из именованной коллекции window.frames:
по номеру - window.frames[0] – объект window для первого фрейма в документе
по имени  - window.frames.iframeName – объект window для фрейма с аттрибутом name равным iframeName

// Ифрейм может иметь другие ифреймы внутри. Таким образом, объекты window создают иерархию. 
// Навигация по ним выглядит так:
window.frames – коллекция «дочерних» window (для вложенных фреймов)
window.parent – ссылка на «родительский» (внешний) window
window.top – ссылка на самого верхнего родителя

if (window == top) { // текущий window == window.top?
  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');
}

// Метод postMessage позволяет общаться двум окнам с любыми источниками:
// Отправитель вызывает targetWindow.postMessage(data, targetOrigin)
// Если targetOrigin не '*', тогда браузер проверяет имеет ли targetWindow источник targetOrigin
// Если это так, тогда targetWindow вызывает событие message со специальными свойствами:
// origin – источник окна отправителя (например, http://my.site.com )
// source – ссылка на окно отправитель.
// data – данные, может быть объектом везде, кроме IE (в IE только строки).
// В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.





		/*--- Сетевые запросы ---*/	


// Простые локальные серверы (ограничен функционал): browsersync или liveServer (vsc) + для запуска серверной  
// части, что бы файл с БД (db.json) отдавал данные - json-server (https://www.npmjs.com/package/json-server).
// OpenServer, MAMP - полноценные локальные серверы, поддерживающие все запросы, не только GET.
// https://jsonplaceholder.typicode.com - сервис для тестирования запросов всех видов

// JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.
// Когда данные "летают" по сети, то они передаются в формате строки! Поэтому для обработки ее нужно распарсить.
// Выбирая метод запроса мы говорим что именно нужно сделать; GET-запрос предназначен для получения каких-либо 
// данных, POST - для создания, DELETE - для удаления, PUT - для полного обновления элемента, PATCH - для 
// частичного обновления элемента.
// GET - запрос, скачивающий содержимое по адресу url; когда мы открываем страницу в интернете - это GET-запрос.

// Если мы отправляем форму, то это POST запрос; обычно с методом POST принимаются дополнительные параметры, 
// так называемый body (тело запроса), то есть то с чем отправляется запрос. body должно быть JSON строкой.

// AJAX (Asynchronous JavaScript And XML) - технология, позволяющая отправлять сетевые запросы и получать 
// ответы в фоновом режиме (без перезагрузки страницы)



		//  XMLHttpRequest  //

// XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу 
// 								  без перезагрузки страницы

// Чтобы сделать запрос, нам нужно выполнить 3 шага:
1. Создать XMLHttpRequest:    let xhr = new XMLHttpRequest(); // у конструктора нет аргументов
2. Инициализировать его:      xhr.open(method, URL, [async, user, password])
// - method – HTTP-метод. Обычно это "GET" или "POST
// - async – если указать false, тогда запрос будет выполнен синхронно
// - user, password – логин и пароль для базовой HTTP-авторизации (если требуется)
// вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос
3. Послать запрос:            xhr.send([body])
// Некоторые типы запросов, такие как GET, не имеют тела. А некоторые, 
// как, например, POST, используют body, чтобы отправлять данные на сервер

// Слушать события на xhr, чтобы получить ответ; три наиболее используемых события:
- load – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404
- error – когда запрос не может быть выполнен, например, нет соединения или невалидный URL
- progress – происходит периодически во время загрузки ответа, сообщает о прогрессе

// После ответа сервера мы можем получить результат запроса в следующих свойствах xhr:
- status - код состояния {200, 404, 403...}
- statusText - сообщение о состоянии ответа HTTP {строка}: обычно OK для 200, Not Found для 404
- response {в старом коде может встречаться как responseText} - тело ответа сервера

// Мы можем использовать свойство xhr.responseType, чтобы указать ожидаемый тип ответа:
"" (по умолчанию) – строка
"text" – строка
"arraybuffer" – ArrayBuffer (для бинарных данных, смотрите в ArrayBuffer, бинарные массивы)
"blob" – Blob (для бинарных данных, смотрите в Blob)
"document" – XML-документ (может использовать XPath и другие XML-методы)
"json" – JSON (чтобы ответ был в виде распарсеного json)

// У XMLHttpRequest есть состояния, которые меняются по мере выполнения запроса. 
// Текущее состояние можно посмотреть в свойстве xhr.readyState (старое); список всех состояний:
UNSENT = 0; // исходное состояние
OPENED = 1; // вызван метод open
HEADERS_RECEIVED = 2; // получены заголовки ответа
LOADING = 3; // ответ в процессе передачи (данные частично получены)
DONE = 4; // запрос завершён

// Изменения в состоянии объекта запроса генерируют событие readystatechange (старое):
// xhr.onreadystatechange = function() {
//   if (xhr.readyState == 3) {
//     // загрузка
//   }
//   if (xhr.readyState == 4) {
//     // запрос завершён
//   }
// }

// Если мы передумали делать запрос, можно отменить его вызовом xhr.abort().
// При этом генерируется событие abort, а xhr.status устанавливается в 0.

// HTTP-заголовки:
// XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.
// Для работы с HTTP-заголовками есть 3 метода: 
- setRequestHeader(name, value); 		например, xhr.setRequestHeader('Content-Type', 'application/json')
- getResponseHeader(name); 					например, xhr.getResponseHeader('Content-Type')
- getAllResponseHeaders() - возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2; в виде единой строки


Событие progress срабатывает только на стадии загрузки ответа с сервера
// А именно: если мы отправляем что-то через POST-запрос, XMLHttpRequest сперва отправит наши данные (тело запроса) 
// на сервер, а потом загрузит ответ  сервера. И событие progress будет срабатывать только во вовремя загрузки ответа.
Существует другой объект, без методов, только для отслеживания событий отправки - xhr.upload
// Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:
// loadstart – начало загрузки данных.
// progress – генерируется периодически во время отправки на сервер.
// abort – загрузка прервана.
// error – ошибка, не связанная с HTTP.
// load – загрузка успешно завершена.
// timeout – вышло время, отведённое на загрузку (при установленном свойстве timeout).
// loadend – загрузка завершена, вне зависимости от того, как – успешно или нет.
xhr.upload.onprogress = function(event) {
  alert(`Отправлено ${event.loaded} из ${event.total} байт`);
};
xhr.upload.onload = function() {
  alert(`Данные успешно отправлены.`);
};
xhr.upload.onerror = function() {
  alert(`Произошла ошибка во время отправки: ${xhr.status}`);
};



		//  Fetch  //

let promise = fetch(url, [options]) - возвращает промис
// - url – URL для отправки запроса
// - options – дополнительные параметры: метод, body, заголовки и так далее
Без options это простой GET-запрос, скачивающий содержимое по адресу url

// Процесс получения ответа обычно происходит в два этапа:

// 1. Во-первых, promise выполняется с объектом встроенного класса Response 
// в качестве результата, как только сервер пришлёт заголовки ответа.
// На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился 
// ли он успешно, а также посмотреть заголовки, но пока без тела ответа.
// Мы можем увидеть HTTP-статус в свойствах ответа:
status – код статуса HTTP-запроса, например 200
ok – будет true, если код HTTP-статуса в диапазоне 200-299

// 2. Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.
// Response предоставляет несколько методов ( возвращающих промисы ) для доступа к телу ответа в различных форматах:
response.text() – читает ответ и возвращает как обычный текст
response.json() – декодирует ответ в формате JSON
response.formData() – возвращает ответ как объект FormData
response.blob() – возвращает объект как Blob (бинарные данные с типом)
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных)
response.body – это объект ReadableStream («поток для чтения»), с помощью которого можно считывать тело запроса по частям


// Заголовки ответа хранятся в похожем на Map объекте response.headers. Это не совсем Map, но мы можем использовать 
// такие же методы, как с Map, чтобы получить заголовок по его имени или перебрать заголовки в цикле:
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');
// получить один заголовок
alert(response.headers.get('Content-Type')) // application/json; charset=utf-8
// перебрать все заголовки
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`)
}

// для отправки POST запроса в fetch нужно указывать дополнительные параметры (метод, body, заголовки), например:
// let user = {
//   name: 'John',
//   surname: 'Smith'
// };

// let response = await fetch('/article/fetch/post/user', {
//   method: 'POST',
//   headers: {
//     'Content-Type': 'application/json'
//   },
//   body: JSON.stringify(user)
// });

// let result = await response.json();
// alert(result.message);



		// FormData //

// FormData - это объект, представляющий данные HTML формы
// Если передать в конструктор элемент HTML-формы form, то 
// создаваемый объект автоматически прочитает из неё поля
let formData = new FormData([form])

// Методы для работы с сетью, например fetch, позволяют указать объект FormData в свойстве тела запроса body.
// Он будет соответствующим образом закодирован и отправлен с заголовком Content-Type: form/multipart.
// То есть, для сервера это выглядит как обычная отправка формы.

// С помощью указанных ниже методов мы можем изменять поля в объекте FormData:
formData.append(name, value) – добавляет к объекту поле с именем name и значением value
formData.append(name, blob, fileName) – добавляет поле, как будто в форме имеется элемент <input type="file">, 
																				третий аргумент fileName устанавливает имя файла, как будто это имя 
																				из файловой системы пользователя
formData.delete(name) – удаляет поле с заданным именем name
formData.get(name) – получает значение поля с именем name
formData.has(name) – если существует поле с именем name, то возвращает true

// Ещё существует метод set, его синтаксис такой же, как у append. Разница в том, что .set удаляет все уже 
// имеющиеся поля с именем name и только затем добавляет новое. То есть этот метод гарантирует, что будет 
// существовать только одно поле с именем name, в остальном он аналогичен .append:
formData.set(name, value)
formData.set(name, blob, fileName)

// Поля объекта formData можно перебирать, используя цикл for..of:  for (let [name, value] of formData)

// Объекты FormData всегда отсылаются с заголовком Content-Type: form/multipart, этот способ кодировки 
// позволяет отсылать файлы. Таким образом, поля <input type="file"> тоже отправляются, как это и 
// происходит в случае обычной формы:
// <form id="formElem">
//   <input type="text" name="firstName" value="John">
//   Картинка: <input type="file" name="picture" accept="image/*">
//   <input type="submit">
// </form>
// <script>
//   formElem.onsubmit = async (e) => {
//     e.preventDefault();

//     let response = await fetch('/article/formdata/post/user-avatar', {
//       method: 'POST',
//       body: new FormData(formElem)
//     });

//     let result = await response.json();

//     alert(result.message);
//   };
// </script>



		// Fetch: ход загрузки (получения данных) //

// В fetch нет способа отслеживать процесс отправки. Для этого используйте XMLHttpRequest.
// Однако fetch позволяет отслеживать процесс получения данных.
// Чтобы отслеживать ход загрузки данных с сервера, можно использовать свойство response.body. 
// Это ReadableStream («поток для чтения») – особый объект, который предоставляет тело ответа 
// по частям, по мере поступления; пример:

const reader = response.body.getReader()
while(true) {
  // done становится true в последнем фрагменте
  // value - Uint8Array из байтов каждого фрагмента
  const {done, value} = await reader.read() // деструктурирем объект, получаемый в результате await reader.read()
  if (done) {
    break
  }
  console.log(`Получено ${value.length} байт`)
}



		// Fetch: прерывание запроса (и любых других асинхронных операций) //

// метод fetch возвращает промис. А в JavaScript в целом нет понятия «отмены» промиса;
// для прерывания запросы fetch (и для любых других асинхронных операций) существует 
// специальный встроенный объект: AbortController

// 1. Создаем контроллер
let controller = new AbortController();
controller имеет единственный метод abort() и единственное свойство signal. При вызове abort():
- генерируется событие с именем abort на объекте controller.signal
- свойство controller.signal.aborted становится равным true
Все, кто хочет узнать о вызове abort(), ставят обработчики на controller.signal, чтобы отслеживать его

// 2. Передаем свойство signal опцией в метод fetch:
fetch(url, {
  signal: controller.signal
})
// метод fetch умеет работать с AbortController, он слушает событие abort на signal

// 3. чтобы прервать выполнение fetch, вызываем abort()
controller.abort() // когда fetch отменяется, его промис завершается с ошибкой AbortError

// AbortController – масштабируемый, он позволяет отменить несколько вызовов fetch одновременно:
let urls = [...]
let controller = new AbortController()

let ourJob = new Promise((resolve, reject) => { // наша задача
  ...
  controller.signal.addEventListener('abort', reject)
})

let fetchJobs = urls.map(url => fetch(url, { // запросы fetch
  signal: controller.signal
}))

// ожидать выполнения нашей задачи и всех запросов
let results = await Promise.all([...fetchJobs, ourJob])

controller.abort() // прервёт все вызовы fetch и наши задачи



		// Объекты URL //

// Встроенный класс URL предоставляет удобный интерфейс для создания и разбора URL-адресов.
// Нет сетевых методов, которые требуют именно объект URL, обычные строки вполне подходят. 
// Так что, технически, мы не обязаны использовать URL. Но иногда он может быть весьма удобным.
let url = new URL(url, [base])
url – полный URL-адрес или только путь, если указан второй параметр
base – необязательный «базовый» URL
// пример:
let url1 = new URL('https://javascript.info/profile/admin')
let url2 = new URL('/profile/admin', 'https://javascript.info')

// Объект URL даёт доступ к компонентам URL, поэтому это отличный способ «разобрать» URL-адрес, например:
let url = new URL('https://javascript.info:8080/path/page?p1=v1&p2=v2#hash');
alert(url.protocol) // https:
alert(url.host)     // javascript.info:8080 (hostname + port)
alert(url.hostname) // javascript.info
alert(url.port)     // 8080
alert(url.pathname) // /path/page
alert(url.search) 	// ?p1=v1&p2=v2
alert(url.hash) 		// #hash



		// WebSocket //

// Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное 
// соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и 
// дополнительных HTTP-запросов. Нет ограничений, связанных с кросс-доменными запросами.

// Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе 
// специальный протокол ws (также существует протокол wss://, использующий шифрование TLS для безопасности):
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello")

// Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
// open – соединение установлено
// message – получены данные
// error – ошибка
// close – соединение закрыто

// А если мы хотим отправить что-нибудь, то вызов socket.send(data) сделает это.
socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
}
socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
}
socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
}
socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
}

// Метод WebSocket .send() может отправлять и текстовые и бинарные данные.
// Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, 
// ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате.
socket.send(body)

// При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем 
// выбрать один из двух форматов: Blob или ArrayBuffer. Это задаётся свойством socket.bufferType, 
// по умолчанию оно равно "blob", так что бинарные данные поступают в виде Blob-объектов.
socket.bufferType = "arraybuffer"
socket.onmessage = (event) => {
  // event.data является строкой (если текст) или arraybuffer (если двоичные данные)
}

// Обычно, когда сторона хочет закрыть соединение (браузер и сервер имеют равные права), они отправляют 
// «фрейм закрытия соединения» с кодом закрытия и указывают причину в виде текста. Метод для этого:
socket.close([code], [reason])
// code – специальный WebSocket-код закрытия (не обязателен)
// reason – строка с описанием причины закрытия (не обязательна)
// Затем противоположная сторона в обработчике события close получит и код code и причину reason, например:

// закрывающая сторона:
socket.close(1000, "работа закончена");
// другая сторона:
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "работа закончена"
  // event.wasClean === true (закрыто чисто)
}

// Чтобы получить состояние соединения, существует дополнительное свойство socket.readyState со значениями:
// 0 – «CONNECTING»: соединение ещё не установлено
// 1 – «OPEN»: обмен данными
// 2 – «CLOSING»: соединение закрывается
// 3 – «CLOSED»: соединение закрыто





		/*--- Хранение данных в браузере ---*/	


		// Куки, document.cookie

// Ку́ки (англ. cookie, буквально — печенье) — небольшой фрагмент данных, отправленный веб-сервером и хранимый на 
// компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего 
// сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса.

// Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Куки обычно устанавливаются 
// веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый 
// запрос на тот же домен при помощи заголовка Cookie.

// Один из наиболее частых случаев использования куки – это аутентификация:
// При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки 
// со специальным уникальным идентификатором сессии («session identifier»).
// Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
// Таким образом, сервер понимает, кто сделал запрос.

// Значение document.cookie состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки
alert( document.cookie ); // cookie1=value1; cookie2=value2;...
// Чтобы найти определённое куки, достаточно разбить строку из document.cookie по ;, и затем найти нужный ключ

// Мы можем писать в document.cookie. Но это не просто данные, а акcессор (геттер/сеттер). Присваивание обрабатывается 
// особым образом. Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные
document.cookie = "user=John"; // обновляем только куки с именем 'user'
alert(document.cookie); // показываем все куки

// специальные символы (пробелы), требуется кодирование
let name = "my name";
let value = "John Smith"
// кодирует в my%20name=John%20Smith
document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);

// одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).

// Настройки куки:
// - path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
// - domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
// - expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
// - secure делает куки доступным только при использовании HTTPS.
// - samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.



		// LocalStorage, sessionStorage

Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.

- key и value должны быть строками {если value объект/массив..., то JSON.stringify(value)}
- Лимит 2 Мб+, зависит от браузера
- Данные не имеют «времени истечения»
- Данные привязаны к источнику {домен/протокол/порт}

localStorage { данные сохраняются даже после перезапуска браузера }:
- совместно используется между всеми вкладками и окнами с одинаковым источником
- «Переживает» перезапуск браузера

sessionStorage { данные сохраняются после обновления страницы }:
- разделяется в рамках вкладки браузера, среди ифреймов из того же источника
- «Переживает» перезагрузку страницы {но не закрытие вкладки}


// API (localStorage и sessionStorage):
- setItem(key, value) – сохранить пару ключ/значение
- getItem(key) – получить данные по ключу key
- removeItem(key) – удалить значение по ключу key
- clear() – удалить всё
- key(index) – получить ключ на заданной позиции
- length – количество элементов в хранилище
- используйте Object.keys для получения всех ключей
- можно обращаться к ключам как к обычным свойствам объекта, в этом случае событие storage не срабатывает

// например
localStorage.setItem('test', 1)
alert( localStorage.getItem('test') ) // 1

Событие storage:
// Срабатывает при вызове setItem, removeItem, clear;
// Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea;
// Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри 
// вкладки для sessionStorage, глобально для localStorage).





		/* Анимация */

// Когда завершается анимация, срабатывает событие transitionend. Оно широко используется для 
// выполнения действий после завершения анимации, а также для создания последовательности анимаций.
Объект события transitionend содержит ряд полезных свойств:
event.propertyName - // имя свойства, анимация которого завершилась. Может быть полезным, если мы анимируем несколько свойств
event.elapsedTime - // время (в секундах), которое заняла анимация, без учёта transition-delay



		// JavaScript-анимации

// Есть несколько известных способов работать с анимацией на JavaScript. Например, можно использовать функцию 
// таймера — setTimeout или setInterval — и обновлять стили каждые несколько миллисекунд. Другой подход — создать 
// цикл, который изменяет стили насколько возможно часто в тот период, пока анимация продолжается. Логика обоих 
// подходов такая: дать браузеру большое количество кадров анимации и надеяться на то, что он выдаст плавное движение.
// Однако на практике эти решения оставляют желать лучшего. Движок рендеринга часто захлебывается на большом количестве 
// задач рендеринга — и зачастую еще не может отобразить кадр, когда уже получает инструкции на отображение следующего. 
// Так что даже если браузер и рендерит столько кадров анимации, сколько может, из-за выпавших кадров анимация все 
// равно получается рваной, не говоря уже о проблемах с производительностью, к которым приводит решение нагрузить процессор 
// слишком большим количеством задач.
// В действительности лучше отображать меньшее количество кадров в секунду, но сделать это количество постоянным. Дело в 
// том, что наш глаз воспринимает небольшие отклонения в частоте, и несколько выпавших кадров режут глаз больше, чем более 
// низкое количество кадров в секунду. Вот здесь на помощь приходит встроенный в HTML5 API requestAnimationFrame.

// Анимация реализуется через последовательность кадров, каждый из которых немного меняет HTML/CSS-свойства.
// requestAnimationFrame выполняет передаваемый в нее callback примерно каждые 16,7ms - 60fps ( 1000ms / 60frames = 16.7ms )
// Если мы хотим замедлить анимацию, что бы было меньше 60fps, можно сделать так:
let framesPerSecond = 10
function animate() {
  setTimeout(function() {
    requestAnimationFrame(animate)
    // animating/drawing code goes here
  }, 1000 / framesPerSecond)
}


// Можно использовать для анимации setInterval, например:
let start = Date.now() // запомнить время начала
let timer = setInterval( function() {
  // сколько времени прошло с начала анимации?
  let timePassed = Date.now() - start
  if (timePassed >= 2000) {
    clearInterval(timer) // закончить анимацию через 2 секунды
    return
  }

  // отрисовать анимацию на момент timePassed, прошедший с начала анимации
  draw(timePassed)
}, 20)
// в то время как timePassed идёт от 0 до 2000
// left изменяет значение от 0px до 400px
function draw(timePassed) {
  train.style.left = timePassed / 5 + 'px'
}


// Однако если одновременно запущено несколько анимаций, то это может сильно нагрузить процессор.
// Поэтому для оптимизации лучше использовать встроенную ф-ию requestAnimationFrame(callback)
let requestId = requestAnimationFrame(callback) // выполнить callback при первой возможности, а не с заданным интервалом
// Функция callback имеет один аргумент – время прошедшее с момента начала загрузки страницы в миллисекундах (timestamp)
// Такой вызов планирует запуск функции callback на ближайшее время, когда браузер сочтёт возможным осуществить анимацию.

// Если в callback происходит изменение элемента, тогда оно будет сгруппировано с другими requestAnimationFrame и 
// CSS-анимациями. Таким образом браузер выполнит один геометрический пересчёт и отрисовку, вместо нескольких

// Значение requestId может быть использовано для отмены анимации:
cancelAnimationFrame(requestId)





		/* Веб-компоненты */


		// Пользовательские элементы (Custom Elements)

// Мы можем создавать пользовательские HTML-элементы, описываемые нашим классом, со 
// своими методами и свойствами, событиями и так далее.

// Существует два вида пользовательских элементов:
- 1. автономные пользовательские элементы – «полностью новые» элементы, расширяющие абстрактный класс HTMLElement
- 2. пользовательские встроенные элементы – элементы, расширяющие встроенные, например кнопку HTMLButtonElement

1. автономные пользовательские элементы создаются путём создания класса со специальными методами {они необязательные}:
class MyElement extends HTMLElement {
  constructor() {
    super()
    // элемент создан
  }
  connectedCallback() {
    // браузер вызывает этот метод при добавлении элемента в документ
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }
  disconnectedCallback() {
    // браузер вызывает этот метод при удалении элемента из документа
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }
  static get observedAttributes() {
    return [/* массив имён атрибутов для отслеживания их изменений */]
  }
  attributeChangedCallback(name, oldValue, newValue) {
    // вызывается при изменении одного из перечисленных выше атрибутов
  }
  adoptedCallback() {
    // вызывается, когда элемент перемещается в новый документ
    // (происходит в document.adoptNode, используется очень редко)
  }
  // у элемента могут быть ещё другие методы и свойства
}

После этого нам нужно зарегистрировать элемент
// сообщим браузеру, что <my-element> обслуживается нашим новым классом
customElements.define("my-element", MyElement) // имя пользовательского элемента должно содержать дефис -

// Теперь для любых HTML-элементов с тегом <my-element> создаётся экземпляр MyElement и вызываются 
// вышеупомянутые методы. Также мы можем использовать document.createElement('my-element') в JavaScript.


// Чтобы получить информацию о пользовательских элементах, есть следующие методы:
customElements.get(name) – возвращает класс пользовательского элемента с указанным именем name
customElements.whenDefined(name) – возвращает промис, который переходит в состояние «успешно выполнен» (без значения), 
																	 когда определён пользовательский элемент с указанным именем name


2. пользовательские встроенные элементы требуют ещё один аргумент 
	 в .define указывающий тег ({extends: 'button'}) и атрибут is="..." в HTML, пример:

// Кнопка, говорящая "привет" по клику
class HelloButton extends HTMLButtonElement {
  constructor() {
    super()
    this.addEventListener('click', () => alert("Привет!"))
  }
}
customElements.define('hello-button', HelloButton, {extends: 'button'});
// Наша новая кнопка расширяет встроенную. Так что она сохраняет те же 
// стили и стандартные возможности, наподобие атрибута disabled
<button is="hello-button">Нажми на меня<button>
<button is="hello-button" disabled>Отключена<button>





		/* Регулярные выражения */


		//  Введение: шаблоны и флаги

// Регулярные выражения – мощное средство поиска и замены в строке; 
// Оно состоит из шаблона и необязательных флагов: g, i, m, u, s, y;
// В JS регулярные выражения реализованы отдельным объектом RegExp и интегрированы в методы строк;

// «Длинный» синтаксис:
regexp = new RegExp("шаблон", "флаги") // отличается от короткого возможностью подставлять переменные с помощью `${}`
// «Короткий» синтаксис:
regexp = /шаблон/ // без флагов       
regexp = /шаблон/gmi // с флагами

// флаги:
i - поиск не зависит от регистра - нет разницы между A и a
g - поиск ищет все совпадения, без него – только первое
m - многострочный режим
s - включает режим «dotall», при котором точка может соответствовать символу перевода строки \n
u - включает полную поддержку юникода; Флаг разрешает корректную обработку суррогатных пар
y - режим поиска на конкретной позиции в тексте

// использование регулярных выражений интегрировано в методы строк:       str.match()  и  str.replace()
let str = "Любо, братцы, любо!"
let result = str.match(/любо/gi)  // ['Любо', 'любо'] (массив из 2х совпадений); без флага g массив с первым совпадением

result.length // 2
// Дополнительная информация:
result.index  // 0 (позиция совпадения)
result.input  // Любо, братцы, любо! (исходная строка)

// если совпадений нет, то возвращается не пустой массив, а null
let matches = "JavaScript".match(/HTML/) // = null

// Метод str.replace(regexp, replacement) заменяет совпадения с regexp в 
// строке str на replacement (все, если есть флаг g, иначе только первое)
"We will, we will".replace(/we/i, "I") // I will, we will
"We will, we will".replace(/we/ig, "I") // I will, I will

// В строке замены replacement мы можем использовать специальные комбинации символов для вставки фрагментов совпадения:
// $& - вставляет всё найденное совпадение
"Люблю я HTML тоже".replace(/HTML/, "$& и JavaScript")  // "Люблю я HTML и JavaScript тоже"
// $` - вставляет часть строки до совпадения
"Люблю я HTML тоже".replace(/HTML/, "$` и JavaScript")  // "Люблю я Люблю я  и JavaScript тоже"
// $' -	вставляет часть строки после совпадения
"Люблю я HTML тоже".replace(/HTML/, "$' и JavaScript")  // "Люблю я  тоже и JavaScript тоже"
// $$ -	вставляет символ "$"
"Люблю я HTML тоже".replace(/HTML/, "$$ и JavaScript")  // "Люблю я $ и JavaScript тоже"


// Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false
let str = "Я ЛюБлЮ JavaScript"
let regexp = /люблю/i
regexp.test(str) // true




		//  Символьные классы

// Символьный класс – это специальное обозначение, которое соответствует любому символу из определённого набора
\s - пробел // включает в себя символ пробела, табуляции \t, перевода строки (новой строки) \n
\S - не пробел
\d - цифра
\D - не цифра
\w - слово // буква латинского алфавита или цифра или подчёркивание _
\W - не слово
.  - любой символ, кроме новой строки

// у нас есть номер телефона вида "+7(903)-123-45-67", и нам нужно превратить его в строку только из чисел: 79035419441
let str = "+7(903)-123-45-67"
let regexp = /\d/g // без g только первая цифра
str.match(regexp) // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7
str.match(regexp).join('') // 79031234567
// альтернативный, более короткий путь – найти нецифровые символы \D и удалить их из строки:  
str.replace(/\D/g, '')

// Регулярное выражение может содержать как обычные символы, так и символьные классы
let str = "Есть ли стандарт CSS4?"
let regexp = /C.S\d/
str.match(regexp) // ['CSS4']
// Также мы можем использовать несколько символьных классов:
"I love HTML5!".match(/\s\w\w\w\w\d/) // [' HTML5']




		//  Юникод: флаг "u" и класс \p{...}

// Флаг u включает поддержку Юникода в регулярных выражениях.

// Конкретно, это означает, что:
// Символы из 4 байт воспринимаются как единое целое, а не как два символа по 2 байта.
// Работает поиск по юникодным свойствам \p{…}.

// С помощью юникодных свойств мы можем искать слова на нужных языках, 
// специальные символы (кавычки, обозначения валюты) и тд




		//  Якоря: начало строки ^ и конец $

// У символов каретки ^ и доллара $ есть специальные значения в регулярных выражениях. Они называются «якоря»
Каретка ^ означает совпадение с началом текста, а доллар $ – с концом

// В конкретно этих случаях мы могли бы использовать и методы строк startsWith/endsWith. 
// Регулярные выражения следует применять, когда нужна проверка сложнее.
let str1 = "Mary had a little lamb"
/^Mary/.test(str1) // true 
/lamb$/.test(str1) // true

// Проверка на полное совпадение; Здесь совпадение с \d\d:\d\d ищется не где-то посередине текста, а сразу 
// после начала строки ^, и после него должен быть сразу конец строки $
let goodInput = "12:34"
let badInput = "12:345"
let regexp = /^\d\d:\d\d$/
regexp.test(goodInput) // true
regexp.test(badInput) // false

/^$/ // пустая строка




		//  Многострочный режим якорей ^ $, флаг "m"

// Многострочный режим включается флагом m. Он влияет только на поведение ^ и $. 
// В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.

let str = `1е место: Винни
					 2е место: Пятачок
					 3е место: Слонопотам`
str.match(/^\d/gm) // ['1', '2', '3']    без флага m была бы найдена только первая цифра


let str = `Винни: 1
					 Пятачок: 2
					 Слонопотам: 3`
str.match(/\d$/gm) // ['1', '2', '3']    Без флага m была бы найдена только последняя цифра в первой строке




		//	Граница  \b

Граница слова или числа \b – проверка, как ^ и $

"Hello, Java!".match(/\bJava\b/) 				// ['Java']
"Hello, JavaScript!".match(/\bJava\b/)  // null

"Hello, Java!".match(/\bJava!\b/) // null (! не является «символом слова» \w, поэтому после него нет границы слова)

// Мы можем использовать \b не только со словами, но и с числами
"1 23 456 78".match(/\b\d\d\b/g) // ['23', '78']
'Завтрак в 09:00 в комнате 123:456'.match(/\b\d\d:\d\d\b/) // ['09:00']




		//	Экранирование, специальные символы

// Специальные символы используются для более сложных поисковых конструкций; 
Вот полный перечень этих символов   [ \ ^ $ . | ? * + ( )
// Чтобы использовать специальный символ как обычный его нужно экранировать - добавить к нему обратную косую черту: \.

"Глава 5.1".match(/\d\.\d/) 	// ['5.1']  (совпадение,  "\." - ищет обычную точку
"function g()".match(/g\(\)/) // ['g()']
// Если мы ищем обратную косую черту \, это специальный символ как в обычных 
// строках, так и в регулярных выражениях, поэтому мы должны удвоить её
"1\\2".match(/\\/) // ['\']

// Символ косой черты '/', так называемый «слэш», не является специальным символом, но в JavaScript он 
// используется для открытия и закрытия регулярного выражения: /...шаблон.../, поэтому мы должны экранировать его
"/".match(/\//)  // ['/']

// При передаче строки в new RegExp нужно удваивать обратную косую черту: \\ для 
// экранирования специальных символов, потому что строковые кавычки «съедят» одну черту.




		// 	Наборы и диапазоны [...], «исключающие» диапазоны [^…]

// Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных»
// Для примера, [eao] означает любой из 3-х символов: 'a', 'e' или 'o'. Это называется набором.

// найти [т или х], после которых идёт "оп"
"Топ хоп".match(/[тх]оп/gi) // ['топ', 'хоп']
"Вуаля".match(/В[уа]ля/)	  // null, нет совпадений; ищет "В", затем [у или а], потом "ля"

// Ещё квадратные скобки могут содержать диапазоны символов 
// К примеру, [a-z] соответствует символу в диапазоне от a до z, или [0-5] – цифра от 0 до 5
"Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) // ['xAF']  ищется символ, который либо цифра от 0 до 9, либо буква от A до F

// Также мы можем использовать символьные классы внутри […].  \d – то же самое что и [0-9],   \w – что и [a-zA-Z0-9_]
// Например, если мы хотим найти «символ слова» \w или дефис -, то набор будет: [\w-]

// Помимо обычных диапазонов, есть «исключающие» диапазоны, которые выглядят как [^…]
// Они обозначаются символом каретки ^ в начале диапазона и соответствуют любому символу за исключением заданных
[^aeyo] // любой символ, за исключением 'a', 'e', 'y' или 'o'
[^0-9]  // любой символ, за исключением цифры, то же, что и \D
"alice15@gmail.com".match(/[^\d\sA-Z]/gi) // ['@', '.']

// В квадратных скобках большинство специальных символов можно использовать без экранирования. 
// разрешены без экранирования все специальные символы, кроме случаев, когда они означают что-то особое в наборах.
[-().^+] // ищет один из символов -().^+

"Java".match(/Java[^script]/) // null
"JavaScript".match(/Java[^script]/) // ['JavaS']
"Завтрак в 09:00. Ужин в 21-30".match( /\d\d[:-]\d\d/g ) // ['09:00', '21-30']




		// Квантификаторы +, *, ? и {n}

Квантификатор указывает количество повторений

// Самый простой квантификатор — это число в фигурных скобках: {n}
// Он добавляется к символу (или символьному классу, или набору [...] и т.д.) и указывает, сколько их нам нужно.
"Мне 12345 лет".match(/\d{5}/)  // ['12345']

// Диапазон: {3,5}, от 3 до 5
// Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: \d{3,5}
"Мне не 12, а 1234 года".match(/\d{3,5}/) // ['1234']
// Верхнюю границу можно не указывать. Тогда шаблон \d{3,} найдёт последовательность чисел длиной 3 и более цифр

"+7(903)-123-45-67".match(/\d{1,}/g) // ['7','903','123','45','67']


// Короткие обозначения
+  -  «один или более»; то же самое, что и {1,}   		
"+7(903)-123-45-67".match(/\d+/g)  // ['7','903','123','45','67']

?  -  «ноль или один»; то же самое, что и {0,1}; по сути, делает символ необязательным
"Следует писать color или colour?".match(/colou?r/g) // ['color', 'colour']

*  -  «ноль или более»; то же самое, что и {0,}; то есть символ может повторяться много раз или вообще отсутствовать
"100 10 1".match(/\d0*/g) // ['100', '10', '1']


"Привет!... Как дела?.....".match(/\.{3,}/g) // ['...', '.....']
"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678".match( /#[a-f0-9]{6}\b/gi )  // ['#121212', '#AA00ef']




		// Жадные и ленивые квантификаторы

// У квантификаторов есть два режима работы:

// - Жадный (по умолчанию)
// По умолчанию движок регулярного выражения пытается повторить квантификатор столько раз, сколько это возможно. 
// Например, \d+ получит все возможные цифры. Когда цифры закончатся или он дойдёт до конца строки, движок продолжит 
// искать совпадение для оставшегося шаблона. Если совпадения не будет, он уменьшит количество повторов (осуществит 
// возврат) и попробует снова. Например:
'a "witch" and her "broom" is one'.match(/".+"/g)  // ['"witch" and her "broom"']

// - Ленивый
// Включается с помощью знака вопроса ? после квантификатора. То есть будет *? или +? или даже ??. Движок регулярного 
// выражения пытается найти совпадение для оставшегося шаблона перед каждым повторением квантификатора. Например:
'a "witch" and her "broom" is one'.match(/".+?"/g)  // ['"witch"', '"broom"']


// Альтернативный ленивому вариант поиска "witch", "broom" в жадном режиме: 
'a "witch" and her "broom" is one'.match(/"[^"]+"/g)	// ['"witch"', '"broom"']

// Первый, ленивый шаблон, \d+? попытается получить как можно меньше цифр до первого 
// пробела; Второй \d+? возьмёт только одну цифру, потому что этого будет достаточно
"123 456".match(/\d+? \d+?/g) // ['123', '4']


let str = `... <!-- My -- comment
 test --> ..  <!----> ..
`
// флаг s включает режим «dotall», при котором точка может соответствовать символу перевода строки \n
str.match(/<!--.*?-->/gs)	// ['<!-- My -- comment \n test -->', '<!---->']


// Создайте регулярное выражение, чтобы найти все (открывающие и закрывающие) HTML-теги с их атрибутами
let str = '<> <a href="/"> <input type="radio" checked> <b>'
alert( str.match(/<[^<>]+>/g) ); // ['<a href="/">', '<input type="radio" checked>', '<b>']