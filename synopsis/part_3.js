

					/*** Тематические разделы ***/



		/*--- Фреймы и окна ---*/								


		// Открытие окон и методы window
			
// Pop-up - отдельное окно со своим JavaScript-окружением (в отличае от модальных 
// окон: alert, форма callback...). Всплывающее окно блокируется в том случае, если 
// вызов window.open произошёл не в результате действия посетителя (например, события click)

// Открытие нового окна: 
window.open(url, name, params):
- URL для загрузки в новом окне
- name - имя нового окна; у каждого окна есть свойство window.name, в котором можно задавать, 
какое окно использовать для попапа; таким образом, если уже существует окно с заданным 
именем – указанный в параметрах URL откроется в нем, в противном случае откроется новое окно
- params - строка параметров для нового окна; содержит настройки, разделённые запятыми без пробелов
// например: 
// let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
// width=0,height=0,left=-1000,top=-1000`;
// open('/', 'test', params);

// Доступ к попапу из основного окна:
// Вызов open возвращает ссылку на новое окно. Эта ссылка может быть использована для управления 
// свойствами окна, например, изменения положения и др., например:
// let newWin = window.open("about:blank", "hello", "width=200,height=200");
// newWin.document.write("Hello, world!");

// Доступ к открывшему окну из попапа:
// Попап также может обратиться к открывшему его окну по ссылке window.opener.

win.close() - чтобы закрыть окно     
win.closed  - для проверки, закрыто ли окно

// Методы focus()/blur() и события focus/blur применимы для Pop-up окон



		// Общение между окнами

// Политика «Одинакового источника» (Same Origin) ограничивает доступ окон и фреймов друг к другу.
// Идея заключается в том, что если у пользователя открыто две страницы: john-smith.com и gmail.com, 
// то у скрипта со страницы john-smith.com не будет возможности прочитать письма из gmail.com.

// если у нас есть ссылка на другой объект window, например, на всплывающее окно, созданное с помощью 
// window.open или на window из <iframe> и у этого окна тот же источник, то к нему будет полный доступ

// Внутри <iframe> находится по сути отдельное окно с собственными объектами document и window
iframe.contentWindow   - ссылка на объект window внутри <iframe>
iframe.contentDocument - ссылка на объект document внутри <iframe>

// Событие iframe.onload – по сути то же, что и iframe.contentWindow.onload. Оно сработает, когда 
// встроенное окно полностью загрузится со всеми ресурсами. Но iframe.onload всегда доступно извне ифрейма, 
// в то время как доступ к iframe.contentWindow.onload разрешён только из окна с тем же источником.

// Другой способ получить объект window из <iframe> – забрать его из именованной коллекции window.frames:
по номеру - window.frames[0] – объект window для первого фрейма в документе
по имени  - window.frames.iframeName – объект window для фрейма с аттрибутом name равным iframeName

// Ифрейм может иметь другие ифреймы внутри. Таким образом, объекты window создают иерархию. 
// Навигация по ним выглядит так:
window.frames – коллекция «дочерних» window (для вложенных фреймов)
window.parent – ссылка на «родительский» (внешний) window
window.top – ссылка на самого верхнего родителя

if (window == top) { // текущий window == window.top?
  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');
}

// Метод postMessage позволяет общаться двум окнам с любыми источниками:
// Отправитель вызывает targetWindow.postMessage(data, targetOrigin)
// Если targetOrigin не '*', тогда браузер проверяет имеет ли targetWindow источник targetOrigin
// Если это так, тогда targetWindow вызывает событие message со специальными свойствами:
// origin – источник окна отправителя (например, http://my.site.com )
// source – ссылка на окно отправитель.
// data – данные, может быть объектом везде, кроме IE (в IE только строки).
// В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.





		/*--- Сетевые запросы ---*/	


// browsersync, liveServer (json-server: https://www.npmjs.com/package/json-server) - локальные серверы.
// https://jsonplaceholder.typicode.com - сервис для тестирования запросов всех видов

// JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.
// Когда данные "летают" по сети, то они передаются в формате строки! Поэтому для обработки ее нужно распарсить.
// Выбирая метод запроса мы говорим что именно нужно сделать; GET-запрос предназначен для получения каких-либо 
// данных, POST - для создания, DELETE - для удаления, PUT - для полного обновления элемента, PATCH - для 
// частичного обновления элемента.
// GET - запрос, скачивающий содержимое по адресу url; когда мы открываем страницу в интернете - это GET-запрос.

// Если мы отправляем форму, то это POST запрос; обычно с методом POST принимаются дополнительные параметры, 
// так называемый body (тело запроса), то есть то с чем отправляется запрос. body должно быть JSON строкой.

// AJAX (Asynchronous JavaScript And XML) - технология, позволяющая отправлять сетевые запросы и получать 
// ответы в фоновом режиме (без перезагрузки страницы)



		//  XMLHttpRequest  //

// XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу 
// 								  без перезагрузки страницы

// Чтобы сделать запрос, нам нужно выполнить 3 шага:
1. Создать XMLHttpRequest:    let xhr = new XMLHttpRequest(); // у конструктора нет аргументов
2. Инициализировать его:      xhr.open(method, URL, [async, user, password])
// - method – HTTP-метод. Обычно это "GET" или "POST
// - async – если указать false, тогда запрос будет выполнен синхронно
// - user, password – логин и пароль для базовой HTTP-авторизации (если требуется)
// вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос
3. Послать запрос:            xhr.send([body])
// Некоторые типы запросов, такие как GET, не имеют тела. А некоторые, 
// как, например, POST, используют body, чтобы отправлять данные на сервер

// Слушать события на xhr, чтобы получить ответ; три наиболее используемых события:
- load – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404
- error – когда запрос не может быть выполнен, например, нет соединения или невалидный URL
- progress – происходит периодически во время загрузки ответа, сообщает о прогрессе

// После ответа сервера мы можем получить результат запроса в следующих свойствах xhr:
- status - код состояния {200, 404, 403...}
- statusText - сообщение о состоянии ответа HTTP {строка}: обычно OK для 200, Not Found для 404
- response {в старом коде может встречаться как responseText} - тело ответа сервера

// Мы можем использовать свойство xhr.responseType, чтобы указать ожидаемый тип ответа:
// "" (по умолчанию) – строка,
// "text" – строка,
// "arraybuffer" – ArrayBuffer (для бинарных данных, смотрите в ArrayBuffer, бинарные массивы),
// "blob" – Blob (для бинарных данных, смотрите в Blob),
// "document" – XML-документ (может использовать XPath и другие XML-методы),
// "json" – JSON (парсится автоматически).

// У XMLHttpRequest есть состояния, которые меняются по мере выполнения запроса. 
// Текущее состояние можно посмотреть в свойстве xhr.readyState (старое); список всех состояний:
UNSENT = 0; // исходное состояние
OPENED = 1; // вызван метод open
HEADERS_RECEIVED = 2; // получены заголовки ответа
LOADING = 3; // ответ в процессе передачи (данные частично получены)
DONE = 4; // запрос завершён

// Изменения в состоянии объекта запроса генерируют событие readystatechange (старое):
// xhr.onreadystatechange = function() {
//   if (xhr.readyState == 3) {
//     // загрузка
//   }
//   if (xhr.readyState == 4) {
//     // запрос завершён
//   }
// }

// Если мы передумали делать запрос, можно отменить его вызовом xhr.abort().
// При этом генерируется событие abort, а xhr.status устанавливается в 0.

// HTTP-заголовки:
// XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.
// Для работы с HTTP-заголовками есть 3 метода: 
- setRequestHeader(name, value); 		например, xhr.setRequestHeader('Content-Type', 'application/json')
- getResponseHeader(name); 					например, xhr.getResponseHeader('Content-Type')
- getAllResponseHeaders() - возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2; в виде единой строки


Событие progress срабатывает только на стадии загрузки ответа с сервера
// А именно: если мы отправляем что-то через POST-запрос, XMLHttpRequest сперва отправит наши данные (тело запроса) 
// на сервер, а потом загрузит ответ  сервера. И событие progress будет срабатывать только во вовремя загрузки ответа.
Существует другой объект, без методов, только для отслеживания событий отправки - xhr.upload
// Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:
// loadstart – начало загрузки данных.
// progress – генерируется периодически во время отправки на сервер.
// abort – загрузка прервана.
// error – ошибка, не связанная с HTTP.
// load – загрузка успешно завершена.
// timeout – вышло время, отведённое на загрузку (при установленном свойстве timeout).
// loadend – загрузка завершена, вне зависимости от того, как – успешно или нет.
xhr.upload.onprogress = function(event) {
  alert(`Отправлено ${event.loaded} из ${event.total} байт`);
};

xhr.upload.onload = function() {
  alert(`Данные успешно отправлены.`);
};
xhr.upload.onerror = function() {
  alert(`Произошла ошибка во время отправки: ${xhr.status}`);
};



		//  Fetch  //

let promise = fetch(url, [options]) - возвращает промис
// - url – URL для отправки запроса
// - options – дополнительные параметры: метод, body, заголовки и так далее
Без options это простой GET-запрос, скачивающий содержимое по адресу url

// Процесс получения ответа обычно происходит в два этапа:

// 1. Во-первых, promise выполняется с объектом встроенного класса Response 
// в качестве результата, как только сервер пришлёт заголовки ответа.
// На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился 
// ли он успешно, а также посмотреть заголовки, но пока без тела ответа.
// Мы можем увидеть HTTP-статус в свойствах ответа:
status – код статуса HTTP-запроса, например 200
ok – будет true, если код HTTP-статуса в диапазоне 200-299

// 2. Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.
// Response предоставляет несколько методов ( возвращающих промисы ) для доступа к телу ответа в различных форматах:
response.text() – читает ответ и возвращает как обычный текст
response.json() – декодирует ответ в формате JSON
response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе)
response.blob() – возвращает объект как Blob (бинарные данные с типом)
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных)
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям


// Заголовки ответа хранятся в похожем на Map объекте response.headers. Это не совсем Map, но мы можем использовать 
// такие же методы, как с Map, чтобы получить заголовок по его имени или перебрать заголовки в цикле:
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');
// получить один заголовок
alert(response.headers.get('Content-Type')) // application/json; charset=utf-8
// перебрать все заголовки
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`)
}

// для отправки POST запроса в fetch нужно указывать дополнительные параметры (метод, body, заголовки), например:
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);