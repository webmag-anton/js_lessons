

					/*** Тематические разделы ***/



		/*--- Фреймы и окна ---*/								


		// Открытие окон и методы window
			
// Pop-up - отдельное окно со своим JavaScript-окружением (в отличае от модальных 
// окон: alert, форма callback...). Всплывающее окно блокируется в том случае, если 
// вызов window.open произошёл не в результате действия посетителя (например, события click)

// Открытие нового окна: 
window.open(url, name, params):
- URL для загрузки в новом окне
- name - имя нового окна. У каждого окна есть свойство window.name, в котором можно задавать, 
какое окно использовать для попапа; таким образом, если уже существует окно с заданным 
именем – указанный в параметрах URL откроется в нем, в противном случае откроется новое окно
- params - строка параметров для нового окна; содержит настройки, разделённые запятыми без пробелов
// например: 
// let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
// width=0,height=0,left=-1000,top=-1000`;
// open('/', 'test', params);

// Доступ к попапу из основного окна:
// Вызов open возвращает ссылку на новое окно. Эта ссылка может быть использована для управления 
// свойствами окна, например, изменения положения и др., например:
// let newWin = window.open("about:blank", "hello", "width=200,height=200");
// newWin.document.write("Hello, world!");

// Доступ к открывшему окну из попапа:
// Попап также может обратиться к открывшему его окну по ссылке window.opener.

win.close() - чтобы закрыть окно     
win.closed  - для проверки, закрыто ли окно

// Методы focus()/blur() и события focus/blur применимы для Pop-up окон



		// Общение между окнами

// Политика «Одинакового источника» (Same Origin) ограничивает доступ окон и фреймов друг к другу.
// Идея заключается в том, что если у пользователя открыто две страницы: john-smith.com и gmail.com, 
// то у скрипта со страницы john-smith.com не будет возможности прочитать письма из gmail.com.

// если у нас есть ссылка на другой объект window, например, на всплывающее окно, созданное с помощью 
// window.open или на window из <iframe> и у этого окна тот же источник, то к нему будет полный доступ

// Внутри <iframe> находится по сути отдельное окно с собственными объектами document и window
iframe.contentWindow   - ссылка на объект window внутри <iframe>
iframe.contentDocument - ссылка на объект document внутри <iframe>

// Событие iframe.onload – по сути то же, что и iframe.contentWindow.onload. Оно сработает, когда 
// встроенное окно полностью загрузится со всеми ресурсами. Но iframe.onload всегда доступно извне ифрейма, 
// в то время как доступ к iframe.contentWindow.onload разрешён только из окна с тем же источником.

// Другой способ получить объект window из <iframe> – забрать его из именованной коллекции window.frames:
по номеру - window.frames[0] – объект window для первого фрейма в документе
по имени  - window.frames.iframeName – объект window для фрейма с аттрибутом name равным iframeName

// Ифрейм может иметь другие ифреймы внутри. Таким образом, объекты window создают иерархию. 
// Навигация по ним выглядит так:
window.frames – коллекция «дочерних» window (для вложенных фреймов)
window.parent – ссылка на «родительский» (внешний) window
window.top – ссылка на самого верхнего родителя

if (window == top) { // текущий window == window.top?
  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');
}

// Метод postMessage позволяет общаться двум окнам с любыми источниками:
// Отправитель вызывает targetWindow.postMessage(data, targetOrigin)
// Если targetOrigin не '*', тогда браузер проверяет имеет ли targetWindow источник targetOrigin
// Если это так, тогда targetWindow вызывает событие message со специальными свойствами:
// origin – источник окна отправителя (например, http://my.site.com )
// source – ссылка на окно отправитель.
// data – данные, может быть объектом везде, кроме IE (в IE только строки).
// В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.