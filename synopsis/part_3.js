

					/*** Тематические разделы ***/



		/*--- Фреймы и окна ---*/								


		// Открытие окон и методы window
			
// Pop-up - отдельное окно со своим JavaScript-окружением (в отличае от модальных 
// окон: alert, форма callback...). Всплывающее окно блокируется в том случае, если 
// вызов window.open произошёл не в результате действия посетителя (например, события click)

// Открытие нового окна: 
window.open(url, name, params):
- URL для загрузки в новом окне
- name - имя нового окна; у каждого окна есть свойство window.name, в котором можно задавать, 
какое окно использовать для попапа; таким образом, если уже существует окно с заданным 
именем – указанный в параметрах URL откроется в нем, в противном случае откроется новое окно
- params - строка параметров для нового окна; содержит настройки, разделённые запятыми без пробелов
// например: 
// let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
// width=0,height=0,left=-1000,top=-1000`;
// open('/', 'test', params);

// Доступ к попапу из основного окна:
// Вызов open возвращает ссылку на новое окно. Эта ссылка может быть использована для управления 
// свойствами окна, например, изменения положения и др., например:
// let newWin = window.open("about:blank", "hello", "width=200,height=200");
// newWin.document.write("Hello, world!");

// Доступ к открывшему окну из попапа:
// Попап также может обратиться к открывшему его окну по ссылке window.opener.

win.close() - чтобы закрыть окно     
win.closed  - для проверки, закрыто ли окно

// Методы focus()/blur() и события focus/blur применимы для Pop-up окон



		// Общение между окнами

// Политика «Одинакового источника» (Same Origin) ограничивает доступ окон и фреймов друг к другу.
// Идея заключается в том, что если у пользователя открыто две страницы: john-smith.com и gmail.com, 
// то у скрипта со страницы john-smith.com не будет возможности прочитать письма из gmail.com.

// если у нас есть ссылка на другой объект window, например, на всплывающее окно, созданное с помощью 
// window.open или на window из <iframe> и у этого окна тот же источник, то к нему будет полный доступ

// Внутри <iframe> находится по сути отдельное окно с собственными объектами document и window
iframe.contentWindow   - ссылка на объект window внутри <iframe>
iframe.contentDocument - ссылка на объект document внутри <iframe>

// Событие iframe.onload – по сути то же, что и iframe.contentWindow.onload. Оно сработает, когда 
// встроенное окно полностью загрузится со всеми ресурсами. Но iframe.onload всегда доступно извне ифрейма, 
// в то время как доступ к iframe.contentWindow.onload разрешён только из окна с тем же источником.

// Другой способ получить объект window из <iframe> – забрать его из именованной коллекции window.frames:
по номеру - window.frames[0] – объект window для первого фрейма в документе
по имени  - window.frames.iframeName – объект window для фрейма с аттрибутом name равным iframeName

// Ифрейм может иметь другие ифреймы внутри. Таким образом, объекты window создают иерархию. 
// Навигация по ним выглядит так:
window.frames – коллекция «дочерних» window (для вложенных фреймов)
window.parent – ссылка на «родительский» (внешний) window
window.top – ссылка на самого верхнего родителя

if (window == top) { // текущий window == window.top?
  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');
}

// Метод postMessage позволяет общаться двум окнам с любыми источниками:
// Отправитель вызывает targetWindow.postMessage(data, targetOrigin)
// Если targetOrigin не '*', тогда браузер проверяет имеет ли targetWindow источник targetOrigin
// Если это так, тогда targetWindow вызывает событие message со специальными свойствами:
// origin – источник окна отправителя (например, http://my.site.com )
// source – ссылка на окно отправитель.
// data – данные, может быть объектом везде, кроме IE (в IE только строки).
// В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.





		/*--- Сетевые запросы ---*/	


// Простые локальные серверы (ограничен функционал): browsersync или liveServer (vsc) + для запуска серверной  
// части, что бы файл с БД (db.json) отдавал данные - json-server (https://www.npmjs.com/package/json-server).
// OpenServer, MAMP - полноценные локальные серверы, поддерживающие все запросы, не только GET.
// https://jsonplaceholder.typicode.com - сервис для тестирования запросов всех видов

// JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.
// Когда данные "летают" по сети, то они передаются в формате строки! Поэтому для обработки ее нужно распарсить.
// Выбирая метод запроса мы говорим что именно нужно сделать; GET-запрос предназначен для получения каких-либо 
// данных, POST - для создания, DELETE - для удаления, PUT - для полного обновления элемента, PATCH - для 
// частичного обновления элемента.
// GET - запрос, скачивающий содержимое по адресу url; когда мы открываем страницу в интернете - это GET-запрос.

// Если мы отправляем форму, то это POST запрос; обычно с методом POST принимаются дополнительные параметры, 
// так называемый body (тело запроса), то есть то с чем отправляется запрос. body должно быть JSON строкой.

// AJAX (Asynchronous JavaScript And XML) - технология, позволяющая отправлять сетевые запросы и получать 
// ответы в фоновом режиме (без перезагрузки страницы)



		//  XMLHttpRequest  //

// XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу 
// 								  без перезагрузки страницы

// Чтобы сделать запрос, нам нужно выполнить 3 шага:
1. Создать XMLHttpRequest:    let xhr = new XMLHttpRequest(); // у конструктора нет аргументов
2. Инициализировать его:      xhr.open(method, URL, [async, user, password])
// - method – HTTP-метод. Обычно это "GET" или "POST
// - async – если указать false, тогда запрос будет выполнен синхронно
// - user, password – логин и пароль для базовой HTTP-авторизации (если требуется)
// вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос
3. Послать запрос:            xhr.send([body])
// Некоторые типы запросов, такие как GET, не имеют тела. А некоторые, 
// как, например, POST, используют body, чтобы отправлять данные на сервер

// Слушать события на xhr, чтобы получить ответ; три наиболее используемых события:
- load – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404
- error – когда запрос не может быть выполнен, например, нет соединения или невалидный URL
- progress – происходит периодически во время загрузки ответа, сообщает о прогрессе

// После ответа сервера мы можем получить результат запроса в следующих свойствах xhr:
- status - код состояния {200, 404, 403...}
- statusText - сообщение о состоянии ответа HTTP {строка}: обычно OK для 200, Not Found для 404
- response {в старом коде может встречаться как responseText} - тело ответа сервера

// Мы можем использовать свойство xhr.responseType, чтобы указать ожидаемый тип ответа:
"" (по умолчанию) – строка
"text" – строка
"arraybuffer" – ArrayBuffer (для бинарных данных, смотрите в ArrayBuffer, бинарные массивы)
"blob" – Blob (для бинарных данных, смотрите в Blob)
"document" – XML-документ (может использовать XPath и другие XML-методы)
"json" – JSON (чтобы ответ был в виде распарсеного json)

// У XMLHttpRequest есть состояния, которые меняются по мере выполнения запроса. 
// Текущее состояние можно посмотреть в свойстве xhr.readyState (старое); список всех состояний:
UNSENT = 0; // исходное состояние
OPENED = 1; // вызван метод open
HEADERS_RECEIVED = 2; // получены заголовки ответа
LOADING = 3; // ответ в процессе передачи (данные частично получены)
DONE = 4; // запрос завершён

// Изменения в состоянии объекта запроса генерируют событие readystatechange (старое):
// xhr.onreadystatechange = function() {
//   if (xhr.readyState == 3) {
//     // загрузка
//   }
//   if (xhr.readyState == 4) {
//     // запрос завершён
//   }
// }

// Если мы передумали делать запрос, можно отменить его вызовом xhr.abort().
// При этом генерируется событие abort, а xhr.status устанавливается в 0.

// HTTP-заголовки:
// XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.
// Для работы с HTTP-заголовками есть 3 метода: 
- setRequestHeader(name, value); 		например, xhr.setRequestHeader('Content-Type', 'application/json')
- getResponseHeader(name); 					например, xhr.getResponseHeader('Content-Type')
- getAllResponseHeaders() - возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2; в виде единой строки


Событие progress срабатывает только на стадии загрузки ответа с сервера
// А именно: если мы отправляем что-то через POST-запрос, XMLHttpRequest сперва отправит наши данные (тело запроса) 
// на сервер, а потом загрузит ответ  сервера. И событие progress будет срабатывать только во вовремя загрузки ответа.
Существует другой объект, без методов, только для отслеживания событий отправки - xhr.upload
// Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:
// loadstart – начало загрузки данных.
// progress – генерируется периодически во время отправки на сервер.
// abort – загрузка прервана.
// error – ошибка, не связанная с HTTP.
// load – загрузка успешно завершена.
// timeout – вышло время, отведённое на загрузку (при установленном свойстве timeout).
// loadend – загрузка завершена, вне зависимости от того, как – успешно или нет.
xhr.upload.onprogress = function(event) {
  alert(`Отправлено ${event.loaded} из ${event.total} байт`);
};
xhr.upload.onload = function() {
  alert(`Данные успешно отправлены.`);
};
xhr.upload.onerror = function() {
  alert(`Произошла ошибка во время отправки: ${xhr.status}`);
};



		//  Fetch  //

let promise = fetch(url, [options]) - возвращает промис
// - url – URL для отправки запроса
// - options – дополнительные параметры: метод, body, заголовки и так далее
Без options это простой GET-запрос, скачивающий содержимое по адресу url

// Процесс получения ответа обычно происходит в два этапа:

// 1. Во-первых, promise выполняется с объектом встроенного класса Response 
// в качестве результата, как только сервер пришлёт заголовки ответа.
// На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился 
// ли он успешно, а также посмотреть заголовки, но пока без тела ответа.
// Мы можем увидеть HTTP-статус в свойствах ответа:
status – код статуса HTTP-запроса, например 200
ok – будет true, если код HTTP-статуса в диапазоне 200-299

// 2. Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.
// Response предоставляет несколько методов ( возвращающих промисы ) для доступа к телу ответа в различных форматах:
response.text() – читает ответ и возвращает как обычный текст
response.json() – декодирует ответ в формате JSON
response.formData() – возвращает ответ как объект FormData
response.blob() – возвращает объект как Blob (бинарные данные с типом)
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных)
response.body – это объект ReadableStream («поток для чтения»), с помощью которого можно считывать тело запроса по частям


// Заголовки ответа хранятся в похожем на Map объекте response.headers. Это не совсем Map, но мы можем использовать 
// такие же методы, как с Map, чтобы получить заголовок по его имени или перебрать заголовки в цикле:
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');
// получить один заголовок
alert(response.headers.get('Content-Type')) // application/json; charset=utf-8
// перебрать все заголовки
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`)
}

// для отправки POST запроса в fetch нужно указывать дополнительные параметры (метод, body, заголовки), например:
// let user = {
//   name: 'John',
//   surname: 'Smith'
// };

// let response = await fetch('/article/fetch/post/user', {
//   method: 'POST',
//   headers: {
//     'Content-Type': 'application/json'
//   },
//   body: JSON.stringify(user)
// });

// let result = await response.json();
// alert(result.message);



		// FormData //

// FormData - это объект, представляющий данные HTML формы
// Если передать в конструктор элемент HTML-формы form, то 
// создаваемый объект автоматически прочитает из неё поля
let formData = new FormData([form])

// Методы для работы с сетью, например fetch, позволяют указать объект FormData в свойстве тела запроса body.
// Он будет соответствующим образом закодирован и отправлен с заголовком Content-Type: form/multipart.
// То есть, для сервера это выглядит как обычная отправка формы.

// С помощью указанных ниже методов мы можем изменять поля в объекте FormData:
formData.append(name, value) – добавляет к объекту поле с именем name и значением value
formData.append(name, blob, fileName) – добавляет поле, как будто в форме имеется элемент <input type="file">, 
																				третий аргумент fileName устанавливает имя файла, как будто это имя 
																				из файловой системы пользователя
formData.delete(name) – удаляет поле с заданным именем name
formData.get(name) – получает значение поля с именем name
formData.has(name) – если существует поле с именем name, то возвращает true

// Ещё существует метод set, его синтаксис такой же, как у append. Разница в том, что .set удаляет все уже 
// имеющиеся поля с именем name и только затем добавляет новое. То есть этот метод гарантирует, что будет 
// существовать только одно поле с именем name, в остальном он аналогичен .append:
formData.set(name, value)
formData.set(name, blob, fileName)

// Поля объекта formData можно перебирать, используя цикл for..of:  for (let [name, value] of formData)

// Объекты FormData всегда отсылаются с заголовком Content-Type: form/multipart, этот способ кодировки 
// позволяет отсылать файлы. Таким образом, поля <input type="file"> тоже отправляются, как это и 
// происходит в случае обычной формы:
// <form id="formElem">
//   <input type="text" name="firstName" value="John">
//   Картинка: <input type="file" name="picture" accept="image/*">
//   <input type="submit">
// </form>
// <script>
//   formElem.onsubmit = async (e) => {
//     e.preventDefault();

//     let response = await fetch('/article/formdata/post/user-avatar', {
//       method: 'POST',
//       body: new FormData(formElem)
//     });

//     let result = await response.json();

//     alert(result.message);
//   };
// </script>



		// Fetch: ход загрузки (получения данных) //

// В fetch нет способа отслеживать процесс отправки. Для этого используйте XMLHttpRequest.
// Однако fetch позволяет отслеживать процесс получения данных.
// Чтобы отслеживать ход загрузки данных с сервера, можно использовать свойство response.body. 
// Это ReadableStream («поток для чтения») – особый объект, который предоставляет тело ответа 
// по частям, по мере поступления; пример:

const reader = response.body.getReader()
while(true) {
  // done становится true в последнем фрагменте
  // value - Uint8Array из байтов каждого фрагмента
  const {done, value} = await reader.read() // деструктурирем объект, получаемый в результате await reader.read()
  if (done) {
    break
  }
  console.log(`Получено ${value.length} байт`)
}



		// Fetch: прерывание запроса (и любых других асинхронных операций) //

// метод fetch возвращает промис. А в JavaScript в целом нет понятия «отмены» промиса;
// для прерывания запросы fetch (и для любых других асинхронных операций) существует 
// специальный встроенный объект: AbortController

// 1. Создаем контроллер
let controller = new AbortController();
controller имеет единственный метод abort() и единственное свойство signal. При вызове abort():
- генерируется событие с именем abort на объекте controller.signal
- свойство controller.signal.aborted становится равным true
Все, кто хочет узнать о вызове abort(), ставят обработчики на controller.signal, чтобы отслеживать его

// 2. Передаем свойство signal опцией в метод fetch:
fetch(url, {
  signal: controller.signal
})
// метод fetch умеет работать с AbortController, он слушает событие abort на signal

// 3. чтобы прервать выполнение fetch, вызываем abort()
controller.abort() // когда fetch отменяется, его промис завершается с ошибкой AbortError

// AbortController – масштабируемый, он позволяет отменить несколько вызовов fetch одновременно:
let urls = [...]
let controller = new AbortController()

let ourJob = new Promise((resolve, reject) => { // наша задача
  ...
  controller.signal.addEventListener('abort', reject)
})

let fetchJobs = urls.map(url => fetch(url, { // запросы fetch
  signal: controller.signal
}))

// ожидать выполнения нашей задачи и всех запросов
let results = await Promise.all([...fetchJobs, ourJob])

controller.abort() // прервёт все вызовы fetch и наши задачи



		// Объекты URL //

// Встроенный класс URL предоставляет удобный интерфейс для создания и разбора URL-адресов.
// Нет сетевых методов, которые требуют именно объект URL, обычные строки вполне подходят. 
// Так что, технически, мы не обязаны использовать URL. Но иногда он может быть весьма удобным.
let url = new URL(url, [base])
url – полный URL-адрес или только путь, если указан второй параметр
base – необязательный «базовый» URL
// пример:
let url1 = new URL('https://javascript.info/profile/admin')
let url2 = new URL('/profile/admin', 'https://javascript.info')

// Объект URL даёт доступ к компонентам URL, поэтому это отличный способ «разобрать» URL-адрес, например:
let url = new URL('https://javascript.info:8080/path/page?p1=v1&p2=v2#hash');
alert(url.protocol) // https:
alert(url.host)     // javascript.info:8080 (hostname + port)
alert(url.hostname) // javascript.info
alert(url.port)     // 8080
alert(url.pathname) // /path/page
alert(url.search) 	// ?p1=v1&p2=v2
alert(url.hash) 		// #hash



		// WebSocket //

// Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное 
// соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и 
// дополнительных HTTP-запросов. Нет ограничений, связанных с кросс-доменными запросами.

// Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе 
// специальный протокол ws (также существует протокол wss://, использующий шифрование TLS для безопасности):
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello")

// Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
// open – соединение установлено
// message – получены данные
// error – ошибка
// close – соединение закрыто

// А если мы хотим отправить что-нибудь, то вызов socket.send(data) сделает это.
socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
}
socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
}
socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
}
socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
}

// Метод WebSocket .send() может отправлять и текстовые и бинарные данные.
// Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, 
// ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате.
socket.send(body)

// При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем 
// выбрать один из двух форматов: Blob или ArrayBuffer. Это задаётся свойством socket.bufferType, 
// по умолчанию оно равно "blob", так что бинарные данные поступают в виде Blob-объектов.
socket.bufferType = "arraybuffer"
socket.onmessage = (event) => {
  // event.data является строкой (если текст) или arraybuffer (если двоичные данные)
}

// Обычно, когда сторона хочет закрыть соединение (браузер и сервер имеют равные права), они отправляют 
// «фрейм закрытия соединения» с кодом закрытия и указывают причину в виде текста. Метод для этого:
socket.close([code], [reason])
// code – специальный WebSocket-код закрытия (не обязателен)
// reason – строка с описанием причины закрытия (не обязательна)
// Затем противоположная сторона в обработчике события close получит и код code и причину reason, например:

// закрывающая сторона:
socket.close(1000, "работа закончена");
// другая сторона:
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "работа закончена"
  // event.wasClean === true (закрыто чисто)
}

// Чтобы получить состояние соединения, существует дополнительное свойство socket.readyState со значениями:
// 0 – «CONNECTING»: соединение ещё не установлено,
// 1 – «OPEN»: обмен данными,
// 2 – «CLOSING»: соединение закрывается,
// 3 – «CLOSED»: соединение закрыто.